도메인 모델과 BoundedContext     
==============================    
# 도메인 모델과 경계     
도메인 모델 설계시 흔히 하는 실수가 **도메인을 완벽하게 표현하는 단일 모델을 만드는 것이다.**     
앞서 서적 초반에 언급했듯이 도메인은 그 하위 도메인으로 구성되어있기에      
한 개의 모델로 여러 하위 도메인을 모두 표현하려고하면 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.      
   
**이름은 같지만 다른 역할**   
* **카탈로그 상품 :** 상품 이미지, 상품명, 상품 가격과 같은 **상품 정보**  
* **재고관리 상품 :** 실존하는 개별 객체를  추적하기 위한 목적   

이들은 이름만 같지 실제로 의미하는 것은 다르다.       
카탈로그에서 물리적으로 1개인 상품은, 재고관리에서 여러 개 존재할 수 있다.        
즉, **논리적으로 같은 존재처럼 보이지만 `하위 도메인`에 따라 다른 용어를 사용하는 경우도 있다.**     
    
[]()     
 
**이름은 다르지만 같은 역할**   
* **회원 도메인 :** 회원
* **주문 도메인 :** 주문자
* **배송 도메인 :** 보내는 사람
      
반대로 같은 대상이라도 지칭하는 용어가 다를 수 있다.          
**한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.**     
     
```java
// User 클래스가 모든 도메인에서의 사용자를 대표할 수 없다는 뜻이다.      
public class User {
}
```     
  
하위 도메인마다 사용하는 용어가 다르기 때문에       
**올바른 도메인 모델을 개발하려면 `하위 도메인마다` 모델을 만들어야 한다.**         

* **회원 도메인 :** Member.class
* **주문 도메인 :** Orderer.class
* **배송 도메인 :** Sender.class
     
각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야한다.               
여러 하위 도메인 모델이 섞이기 시작하면 모델의 의미가 약해질 뿐만 아니라               
각 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워진다.                        
(그래도 논리적으로 같은 클래스가 여러개이므로 헷갈림을 자초할 수도 있기 때문이다.)        
          
모델은 **특정 컨텍스트 안에서 완전한 의미를 갖는다.**             
이렇게 **특정 컨텍스트별로 구분되는 경계를 DDD 에서는 BOUNDED CONTEXT라고 부른다.**      
     
# BOUNDED CONTEXT    
BOUNDED CONTEXT는 모델의 **한 경계를 결정**하며         
한 개의 BOUNDED CONTEXT는 논리적으로 **한 개의 모델을 갖는다.**          
              
**`BOUNDED CONTEXT`는 용어를 기준으로 구분하고 분리하고 경계를 나눈다.(카탈로그/재고/도메인마다?)**      
그리고 `BOUNDED CONTEXT`는 실제 사용자에게 기능을 제공하는 물리적인 시스템으로    
도메인 모델은 이 `BOUNDED CONTEXT` 안에서 도메인을 구현하도록 한다.     
  
[#](#)     
   
**주문 하위 도메인**       
* 주문 처리팀 : 주문 BOUNDED CONTEXT        
* 결제 처리팀 : 결제 금액 계산 BOUNDED CONTEXT       
* 카탈로그와 재고 관리는 아직 명확히 안 나뉘어져 상품 BOUNDED CONTEXT에서 구현     

이상적으로 **도메인과 BOUNDED CONTEXT가 일대일 관계**를 가지면 좋지만 대부분 그렇지 않다.            
BOUNDED CONTEXT는 기업의 팀 조직 구조에 따라 결정되기 때문이다.
               
**규모가 작은 기업의 경우 하나의 팀에서 `회원`/`주문`/`결제`/`재고`등의 도메인을 처리한다.**           
**즉, 여러 하위 도메인을 하나의 BOUNDED CONTEXT에서 구현한다.**                               
이때, 한 가지 주의점이 있는데 하위 도메인의 모델들이 뒤섞이지 않게 해야 하는 것이다.               
         
한 개의 프로젝트에서 논리적으로 비슷한 모델이 있으면       
전체 하위 도메인을 위한 단일 모델을 만들고 싶은 유혹에 빠지기 쉽다.                
이런 유혹에 걸려들면 단일 모델은 **각각의 고유한 기능을 담지 못하거나 너무 많은 기능을 가지고 있게 된다.**                   
결과적으로 **개별 하위 도메인 모델을 제대로 반영하지 못해서 하위 도메인별 기능 확장을 어렵게 만든다.**                      
**(즉, 공통된 도메인 모델을 사용하려다 보면 각 BOUNDED CONTEXT마다의 고유한 기능을 사용못하게 된다.)**           
           
따라서 한 개의 BOUNDED CONTEXT에서 여러 하위 도메인을 포함하더라도    
하위 도메인마다 구분되는 패키지를 갖도로 구현해야 한다.          
그러면 하위 도메인을 위한 모델이 서로 뒤섞이지 않아서      
하위 도메인마다 BOUNDED CONTEXT를 갖는 효과를 낼 수 있다.            
     
[#](#)     
   
BOUNDED CONTEXT는 **도메인 모델을 구분하는 경계**가 되기 때문에         
BOUNDED CONTEXT는 구현하는 **하위 도메인에 알맞은 모델을 포함한다.**      
      
* **회원 도메인 :** 회원
* **주문 도메인 :** 주문자
* **배송 도메인 :** 보내는 사람 
   
논리적으로 같은 개념이라고 할지라도       
`BOUNDED CONTEXT`에 따라 갖는 모델이 달라지며      
이들은 각 컨텍스트에 최적화 되어있는 형태를 가지고 있다.       

[#](#)  

회원의 Member는 애그리거트 루트이지만 주문의 Order는 벨류가 되고        
카탈로그의 Product는 상품이 속할 Category와 연관을 갖지만         
재고의 Product는 카탈로의 Categorty와 아무런 연관을 갖지 않는다.   

# BOUNDED CONTEXT 구현  
> BOUNDED CONTEXT는 모듈이 아니다.   






















