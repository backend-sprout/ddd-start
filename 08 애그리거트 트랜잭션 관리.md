애그리거트 트랜잭션 관리
==========================
# 애그리거트와 트랜잭션  
한 주문 애그리거트에 대해 아래와 같은 작업이 동시에 일어나면 어떻게 될까?   
  
* `운영자`는 주문 애그리거트의 배송 상태를 배송중으로 변경                  
* `사용자`는 배송지 주소를 변경                  

**`운영자 스레드`와 `고객 스레드`는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.** (메모리 캐시를 사용하지 않을 경우)    

[#asd](#)    
  
`운영자 스레드`와 `고객 스레드`는 개념적으로 동일한 애그리거트다.            
하지만, **물리적으로 서로 다른 애그리거트 객체를 사용한다.**          
              
운영자 스레드가 주문 애그리거트 객체를 배송 상태로 변경하더라도              
고객 스레드가 사용하는 주문 애그리거트 객체에는 영향을 주지 않는다.                    
**결과적으로 고객 스레드의 주문 애그리거트는 아직 `배송 전`이므로 배송지 주소를 변경할 수 있다는 문제를 야기한다.**               
이것이 바로, 레이스 컨디션으로 발생한 치명적인 결함이다.       
  
이 상황에서 두 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 DBMS에 반영한다.        
즉, 배송 상태로 바뀌고 배송지 정보도 바뀌는데 후자로 들어간 객체로 값이 갱신된다는 것이다.       
고객 스레드가 후자라고 가정을 한다면 배송 상태는 `배송 중`으로 바뀌었다가 다시 `배송 전`으로 갱신이 된다.   
**애그리거트의 일관성이 깨지는 상황이 발생한다.**    

이런 문제를 해결하려면 아래 두 가지 중 하나를 해야 한다.    

* 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다.   
* 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.(처음봄)   
  
이 두 가지는 애그리거트 자체의 **트랜잭션**과 관련이 있다.        
DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다.      

애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 **선점 잠금**과 **비선점 잠금** 두 가지 방식이 있다.     

# 선점 잠금    
선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지       
다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식이다.        

[#](#)  
   
스레드1이 애그리거트에 대한 잠금을 진행하면 스레드2는 잠금이 해제 될 때까지 블로킹된다.      
결과적으로 스레드2는 스레드1에서 작업한 내용을 받아다 사용하게 된다.      
   
한 스레드가 애그리거트를 구하고 수정하는 동안, 다른 스레드가 수정할 수 없으므로       
동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.        
   
[#](#)    
      
선점 잠금은 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현한다.        
다수의 DBMS가 for update와 같은 쿼리를 사용해서 특정 레코드에 한 사용자만 접근할 수 있는 잠금 장치를 제공한다.         

**여기 중요**    
JPA의 EntityManager는 `LockModeType`을 인자로 받는 `find()` 메서드를 제공하는데,    
`LockModeType.PESSIMISTIC_WRITE`를 갑으로 전달하면       
해당 엔티티와 매핑된 테이블을 이용해서 선점 잠금 방식을 적용할 수 있다.      

```java
Order order = entityManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE);
```

JPA 프로바이더와 DBMS에 따라 잠금 모드의 구현이 다른데,    
하이버네이트의 경우 `PESSIMISTIC_WRITE_WRITE`잠금 모드로 사용하면    
`for update` 쿼리를 사용해서 선점 잠금을 구현한다.       
    
## 선점 잠금과 교착 상태 


  






      
 
 
 





