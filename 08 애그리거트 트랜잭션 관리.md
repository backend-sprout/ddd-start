애그리거트 트랜잭션 관리
==========================
# 애그리거트와 트랜잭션  
한 주문 애그리거트에 대해 아래와 같은 작업이 동시에 일어나면 어떻게 될까?   
  
* `운영자`는 주문 애그리거트의 배송 상태를 배송중으로 변경                  
* `사용자`는 배송지 주소를 변경                  

**`운영자 스레드`와 `고객 스레드`는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.** (메모리 캐시를 사용하지 않을 경우)    

[#asd](#)    
  
`운영자 스레드`와 `고객 스레드`는 개념적으로 동일한 애그리거트다.            
하지만, **물리적으로 서로 다른 애그리거트 객체를 사용한다.**          
              
운영자 스레드가 주문 애그리거트 객체를 배송 상태로 변경하더라도              
고객 스레드가 사용하는 주문 애그리거트 객체에는 영향을 주지 않는다.                    
**결과적으로 고객 스레드의 주문 애그리거트는 아직 `배송 전`이므로 배송지 주소를 변경할 수 있다는 문제를 야기한다.**               
이것이 바로, 레이스 컨디션으로 발생한 치명적인 결함이다.       
  
이 상황에서 두 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 DBMS에 반영한다.        
즉, 배송 상태로 바뀌고 배송지 정보도 바뀌는데 후자로 들어간 객체로 값이 갱신된다는 것이다.       
고객 스레드가 후자라고 가정을 한다면 배송 상태는 `배송 중`으로 바뀌었다가 다시 `배송 전`으로 갱신이 된다.   
**애그리거트의 일관성이 깨지는 상황이 발생한다.**    

이런 문제를 해결하려면 아래 두 가지 중 하나를 해야 한다.    

* 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다.   
* 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.(처음봄)   

이 두 가지는 애그리거트 자체의 트랜잭션과 관련이 있다.    







      
 
 
 





