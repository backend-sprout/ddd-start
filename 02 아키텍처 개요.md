# 4개의 영역 

1. 표현/UI  
2. 응용
3. 도메인
4. 인프라 스트럭처 

## 표현/UI    
사용자의 **요청을 해석해서 응용 서비스에 전달**하고        
응용 서비스의 **결과를 사용자가 이해할 수 있는 형식으로 변환해서 응답**한다.          
   
**여기서 사용자란? 🤔**   
```
웹 브라우저이거나, REST API를 이용한 외부 시스템일 수 있다.(모바일, 기타 등등)   
```
           
즉, `HTTP 요청`을 **응용 영역이 필요로 하는 형식으로 변환해서 `응용 영역`에 전달**하고             
**`응용 영역의 응답`을 HTTP 응답으로 변환해서 전송한다.**(Model은 해당 사항이 아니다.)             
         
쉽게 말하면,       
`@RequestBody`를 이용해서 `사용자`로부터 넘어온 값을 `HTTP 요청 본문에 담긴 값들을 자바 객체로 변환`한 후 `Service`에 넘기고           
`@ResponseBody`를 이용해서 `Servic`로부터 넘어온 값을 `HTTP 응답 본문의 JSON 객체로 변환`한 후 응답하는 것을 말한다.          
즉, `Controller`가 대표적인 예시라고 보면 된다. (MVC라고 책에서는 나왔는데 더 자세히 말하면)        
         
## 응용   
사용자에게 **제공해야 할 기능을 구현한다.**       
`주문 등록`, `주문 취소`, `상품 상세 조회` 등등...      
        
`응용 영역`은 기능을 구현하기 위해 **도메인 영역의 도메인 모델들을 이용한다.**     

```java
public class CancelOrderService {
      
    @Transactional    
    public void cancelOrder(String orderId) {    
        Order order = findOrderById(orderId);     
        if(order == null) throw new OrderNotFoundException(orderId);      
        order.cancel();   
    }
}  
```  
응용 서비스는 로직을 직접 수행하기 보다는         
**도메인 모델에 로직 수행을 위임한다.(역할과 책임)**              
위 코드도 도메인인 `Order`가 `취소 처리`를 하고 있다.    
        
개인적으로, `역할`/`책임`/`협력`에서 `협력을 하는 공간`이라고도 생가합니다.     
   
## 도메인  
도메인 영역은 **`도메인 모델`을 구현하는 영역**이다.(`Order`, `ShippingInfo` 등등...)        
그리고 **`도메인 모델`은 도메인의 핵심 로직을 구현**한다.     
     
**주문 도메인**     
* 배송지 변경    
* 결제 완료        
* 주문 총액 계산    

## 인프라 스트럭처
인프라스트럭처 영역은 **구현 기술**에 대한 것을 다룬다.     

* `RDBMS` 연동처리
* [메시징 큐](https://ko.wikipedia.org/wiki/%EB%A9%94%EC%8B%9C%EC%A7%80_%ED%81%90)에 메시지 전송하거나 수신    
* `몽고 DB`, `HBase` 를 사용해서 데이터베이스 연동 처리  
* `SMTP`를 이용한 메일 발송 기능 구현      
* `HTTP 클라이언트`를 이용해서 `REST API`를 호출     
  
`인프라 스트럭처 영역`은      
**논리적인 개념을 표현하기 보다는 `실제 구현`을 다룬다.**         
    
`도메인 로직`, `응용 영역`, `표현 영역`은 구현 기술을 사용한 코드를 직접 만들지는 않는다.   
대신, **인프라 스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.**    
     
예시1)        
1. 응용 영역이 DB에 보관된 데이터가 필요
2. 인프라 스트럭처 영역의 DB 모듈을 사용해서 데이터를 읽어온다.   
       
예시2)       
1. SMTP 연동 모듈을 이용해서 메일 발송    
      
사실 여기서 가장 중요하다고 생각하는 점은 **관심사 분리**이다.      
`도메인 로직`, `응용 영역`, `표현 영역`은 **구현 기술을 어떻게 사용했는지 관심이 없다.**         
오로지 `데이터`만을 필요로 하고 **그 데이터를 잘 가공하는 역할만을 한다.**      
즉, 자신의 역할과 책임 -> `코어 밸류`만을 생각할 뿐이다.      
      
# 계층 구조 아키텍처     
`4 영역`을 구성할 때 많이 사용하는 아키텍처가 아래와 같은 구조이다.   
    
[사진](#)    
       
`표현 영역`과 `응용 영역`은 `도메인 영역`을 사용하고,       
`도메인 영역`은 `인프라스트럭처 영역`을 사용하므로 계층 구조가 적당해 보인다.          
물론, 도메인 복잡도에 따라, 응용과 도메인을 분리하기도 하고 한 계층으로 합치기도 한다.         
    
**계층 구조는 특성상**      
* **`상위 계층`에서 `하위 계층`으로의 의존만 존재한다.**  
* **`하위 계층`은 `상위 계층`에 의존하지 않는다.**     
   
```java
@Controller
public class SampleController {
    private final SampleService sampleService; // 하위를 의존
    
    public SampleController(SampleService sampleService) {
        this.sampleService = sampleService;
    }
    ... // 
}
```
우리가 흔히 사용하는 코드를 다시보면    
`상위 계층인 표현 영역`에서 `하위 계층인 응용 영역`을 의존하고 있는 것을 알 수 있다.      
   
[사진](#)  
         
계층 구조를 엄격하게 적용하면 `상위 계층`은 바로 아래의 `하위 계층`에만 의존해야한다.           
하지만, 위와 같이 구현의 편리상 **계층 구조를 유연하게 적용할 수도 있다.**     
     
즉, `응용 계층`은 바로 아래 계층인 `도메인 계층`에 의존하지만       
**외부 시스템과의 연동을 위해** 더 아래 계층인 `인프라 스트럭처 계층`에 의존하기도 한다.          
  
```java
@Service
public class SampleServiceImpl implements SampleService {
  
    private final SampleRepository sampleRepository; // 도메인이 아닌 인프라스트럭처 영역  
                                                     // 상위 계층에 대한 의존이 없다.  
                                                     
    public SampleServiceImpl(SampleRepository sampleRepository) {
        this.sampleRepository = sampleRepository;
    }
     
    public void findById(Long id) {  
        // 여기서 도메인을 얻어서 사용한다.   
        Sample sample = sampleRepository.findById(id).orElseThrow(() ->
                new NoSearchSampleByIdException(id));
    }
    
}
```
       
`응용 영역`과 `도메인 영역`은        
`DB`나 `외부 시스템 연동`을 위해 `인프라 스트럭처의 기능`을 사용하므로        
위와 같은 구조를 사용하는 것이 **직관적으로 이해하기 쉬우며 구현 또한 편리하다.**       
         
하지만, 여기서 짚고 넘어갈 부분은             
자칫 하면, `응용 계층`과 `도메인 계층`이       
**구현 방법에 따라 상세한 구현 기술을 다루는 `인프라 스트럭처에 종속`된다는 점이다.**              
     
## 인프라 스트럭처에 종속된 코드  
예시로 `룰 엔진`을 적용시켜보겠다.         
때로는, 비즈니스 로직이 복잡해지면 객체 지향으로 로직을 구현하는 것보다         
[룰 엔진](https://javacan.tistory.com/entry/118)을 사용하는 방법도 대안이 될 수 있다. (실제로도 사용하는지는 잘 모르겠네요 ㅎㅎ;)        
         
> 룰 엔진을 깊게 다룰 필요는 없다 생각합니다.       
> 다만, 종속된 코드를 보여준다는 주제에 대해서만 파악하면 좋을 것 같습니다.     

**CalculateDiscountService**
```java
public class CalculateDiscountService {
    private DroolsRuleEngine ruleEngine; // 구현 객체를 직접 사용  
    
    public CalculateDiscountService() {
        ruleEngine = new DroolsRuleEngine();
    }
    
    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
        Customer customer = findCustomer(customerId);
        
        MutableMoney money = new MutableMoney(0);
        List<?> facts = Arrays.asList(customer, money);
        facts.addAll(orderLines);
        ruleEngine.evaluate("discountCalculation", facts);
        return money.toImmutableMoney();  
    }
    
}
``` 
**DroolsRuleEngine**    
```java
public class DroolsRuleEngine {
    private KieContainer KContainer;
    
    public DroolsRuleEngine() {
        KieService ks = KieServices.Factory.get();
        KContainer = ks.getKieClasspathContainer();
    }
    
    public void evalute(String sessionName, List<?> facts) {
        KieSession KSession = KContainer.newKieSession(sessionName);
        try {
            facts.forEach(x -> KSession.insert(x));
            KSession.fireAllRules();
        } finally {
            KSession.dispose();
        }
    }
    
}
```  
`DroolsRuleEngine`는 `DroolsRuleEngine`라는 `룰 엔진`을 사용하는 `인프라스트럭처 영역`의 코드다.             
`evalute()` 메서드를 호출하면 **별도의 파일로 작성한 규칙을 이용해서 연산을 수행하는 코드**라고만 생각하자.       
      
**위 코드는 2개의 큰 문제를 가지고 있다.**        
1. **`CalculateDiscountService`만을 테스트하기 어렵다. :**   
   `CalculateDiscountService`를 테스트하려면 `RuleEngine`이 완벽하게 동작해야한다.    
   즉, **`RuleEngine`을 설정 파일을 만든후에야 정상적인 테스트가 가능하다**는 점이다.  
2. **변경이 어렵다.**    
   ```java
        MutableMoney money = new MutableMoney(0);
        List<?> facts = Arrays.asList(customer, money);
        facts.addAll(orderLines);
        ruleEngine.evaluate("discountCalculation", facts);
   ```
   이 코드들은 `Drools`에 특화된 코드로, **변경이 있을 경우 현재 클래스에도 영향이 간다.**     
   즉, `Drools`이 아닌 다른 케이스를 사용하고자 한다면 `CalculateDiscountService`의 코드도 변경해야한다.      
            
이처럼 `CalculateDiscountService`가 구현 객체를 직접 의존하고 있으므로           
다른 구현 기술을 사용하고자 할 때 코드의 많은 부분을 고쳐야한다.     
       
정리하자면, **`인프라 스트럭처`영역의 기술을 직접 의존**하고 있는다면     
**`테스트 어려움`과 `기능 확장의 어려움`이라는 문제가 발생한다.**   
         
## DIP       
`CalculateDiscountService`는 **의미있는 단일 기능을 제공하는 `고수준 모듈`이다.**         
그리고 `고수준 모듈`의 기능을 구현하려면 **여러 하위 기능이 필요하다.**       
예시를 들면, `고객 정보를 구하기`, `룰 실행`라는 `2 가지 하위 기능`이 필요하다.       
       
**`저수준 모듈`은 하위 기능을 실제로 구현한 것이다.**        
`JPA`를 이용해서 고객 정보를읽어오는 모듈과     
`Drools`로 룰을 실행하는 모듈이 저수준 모듈이 된다.     

`고수준 모듈`이 제대로 동작하려면 `저수준 모듈`을 사용해야한다.   
그런데, `고수준 모듈`들이 `저수준 모듈`을 사용하면      
**`테스트 어려움`과 `기능 확장의 어려움`이라는 문제가 발생한다.**     
이를 해결하기 위해서 우리는 **추상화한 인터페이스를 사용하면 된다.**    
      
`CalculaterDiscountService` 입장에 봤을 때 `어떻게 구현`했는지는 중요하지 않다.     
단지, `고객 정보와 구매 정보에 룰을 적용해서 할인 금액을 구한다`는 것이 중요하다.     
   
```java
public interface RuleDiscounter {
    public Money applyRules(Customer customer, List<OrderLine> orderLines);   
}
```
```java
public class CalculateDiscountService {
    private RuleDiscounter ruleDiscounter;
    
    public CalculateDiscountService(RuleDiscounter ruleDiscounter) {
        this.ruleDiscounter = ruleDiscounter;
    }
    
    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
        Customer customer = findCustomer(customerId);
        return ruleDiscounter.applyRules(customer, orderLines);
    }
    
}
```  
```java
public class DroolsRuleEngine implements RuleDiscounter {
    private KieContainer KContainer;
    
    public DroolsRuleEngine() {
        KieService ks = KieServices.Factory.get();
        KContainer = ks.getKieClasspathContainer();
    }
    
    public void evalute(String sessionName, List<?> facts) {
        KieSession KSession = KContainer.newKieSession(sessionName);
        try {
            facts.forEach(x -> KSession.insert(x));
            KSession.fireAllRules();
        } finally {
            KSession.dispose();
        }
    }
    
}
```
이 같이 인터페이스를 참조변수로 두고 구현체를 생성자로 받는다면          
`CalculaterDiscountService`는 더 이상 `특정 구현체`에 의존하지 않게 된다.   
정확히 말하면 `추상화(특정 인터페이스)`를 의존하는 형태가 되었다.       
          
`인터페이스(추상화)`는 고수준 모듈에 속한다.                    
그리고 이를 `구현한 구현체(하위 기능)`들은 **인터페이스를 의존하는 형태가 된다.**
(구현체가 인터페이스를 의존한다는 것은 인터페이스에 맞는 추상 메서드를 정의하기 때문이라고 생각하면 됩니다.)      
       
그렇기에 `고수준 모듈`에서 `저소준 모듈`을 의존하고 있던 기존 형태가 아닌,     
`저소준 모듈`에서 `고수준 모듈`을 의존하는 형태인 `DIP(의존 역전의 원칙)`가 성립된다.
   
**DIP의 원칙**
* **첫째 :** 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
* **둘째 :** 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.
           











