# 애그리거트 개요  

[]()  

상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다.  
즉, **상위 수준에서 모델을 정리하면 복잡한 도메인 모델의 관계를 이해하는데 도움이된다.**      

[]() 

이렇게 작성도니 `상위 수준 모델`을 통해 `개별 객체 단위`를 나타내면 위와 같다.        
그런데 만약, `상위 수준 모델`에 대한 이해 없이 `개별 객체 단위`만 바라보게 된다면?      
더 많은 코드를 보고 도메인 전문가와 더 많은 대화를 나눠야 비로소 상위 수준에서 모델간의 관계가 이해되기 시작한다.        
쉽게 말하자면, `상 -> 하` 가 아닌 `하 -> 상`으로 도메인을 이해하는 것은 매우 어려운 일이다.    
  
앞서 언급했듯이,      
**도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고       
전반적인 구조나 큰 수준에서 도메인간의 파악이 어려워진다.**        
    
`큰 수준에서 도메인간의 파악이 어려워진다는 점`은 곧, 코드를 변경하고 확장하는 것이 어려워진다는 의미이다.      
상위 수준을 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 반영할 수 있는데 그게 아니기 때문이며        
결국에는 이렇게 망가뜨리기가 두렵기 때문에 코드 변경을 최대한 회피하는 쪽으로 협의하게 되고 꼼수를 이용해도 마찬가지이다.        

# 애그리거트 
`애그리 거트`는 **복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들어주는 단위 같은 역할을 한다.**     
앞서 설명한대로, 관련된 객체를 하나의 집합(군)으로 묶어주며     
애그리거트 단위로 바라보면 좀 더 상위 수준에서 도메인 모델간의 관계를 파악하기 쉬워진다.   
   
[]()    
  
앞선 그림과 동일한 모델이지만,     
애그리거트를 이용하게 된다면 모델간의 관계를 개별 모델 수준뿐만 아니라 상위 수준에서도 이해하기 쉽다.      

### 애그리거트와 일관성   

```java
public interface OrderRepository {
    public Order findByNumber(OrderNumber number);
    public void save(Order order);
    public void delete(Order order);
}
```   
  
애그리거트는 일관성을 관리하는 기준이 되기도 한다.      
애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.      
복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.      

### 애그리거트와 라이프 사이클  
애그리거트는 관련된 모델을 하나로 모은 것이기 때문에     
한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.      

```java
 public class Order {
    private List<OrderLine> orderLines;
    private Orderer orderer;
    private Orderer orderer;
    private ShippingInfo shippingInfo;
    
    ... // 메서드는 생략 
}
```

`주문` 애그리거트를 만들려면 `Order`, `OrderLine`, `Orderer`와 같은 관련 객체를 함께 생성해야한다.    
이와 같은 관련 객체를 만들지 않는 그런 경우는 없다.       
물론, 도메인 규칙에 따라 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만       
**대부분 애그리거트에 속한 구성요소는 함께 생성하고 함께 제거한다.**       
      
추가로, 실제 코드를 보면 객체의 참조 시점과 별개로 우선적으로 변수는 선언되어있다.          
앞서 언급했듯이 특수한 경우는 객체를 먼저 만들지 않아도 된다고 한다하더라도(생성자 주입을 안하더라도)     
`Null`값을 참조시키도록 하는 것보다, `준비 클래스`나 `default 클래스`를 만들어두는게 낫다.   
  
### 애그리거트와 경계   
애그리거트는 경계를 갖고 있어 각각의 애그리거트간의 구분이된다.         
그리고 **한 애그리트에 속한 객체는 다른 애그리거트에 속하지 않는다.**         
애그리거트는 독립된 객체 집합(군)이며, 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지않는다.          

* 주문 **--->** 배송지 변경, 주문 상품 개수 변경 
* 주문 **-X->** 회원의 비밀 번호 변경 
     
경계를 설정할 때 기본이 되는 것은 **`도메인 규칙`과 `요구사항`이다.**        
**`도메인 규칙`에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.**         
또한, 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다.   
          
예를 들면 '주문'시점에 같이 생성되는 '상품 개수', '주문자 정보' 등등이 있으며         
`OrderLine의 주문 상품 개수를 변경`하면 도메인 규칙에 따라 `Order의 총 주문 금액 또한 새롭게 계산`해야한다.       
   
#### 애그리거트간의 경계 주의점
흔히, `A가 B를 갖는다.`로 설계할 수 있는 요구사항이 있다면 `A와 B`를 한 애그리거트로 묶어서 생각하기 쉽다.     
하지만, `A가 B를 갖는다`로 해석할 수 있더라도 `A와 B`가 한 애그리트에 속하다는 것은 아니다.     

```java
public class Product {
    private List<Review> reviews = new ArrayList<>(); // 단순히 연관 관계를 가진 객체로 보면 될 것 같다.   
}   
// 상품은 여러 리뷰를 가진다.   
// 리뷰는 하나의 상품에 속한다.     
// 이를 객체로 표현했을 때 위와 같아서 이렇게 표현했습니다.     
```   
  
가장 좋은 예가 `상품리뷰`이다.         
상품 상세 페이지와 함께 리뷰 내용을 보여줘야한다는 요구사항이 있다면          
`Product 엔티티`와 `Review 엔티티`가 한 애그리거트에 속한다고 생각할 수 있다.            
하지만 이 둘은 서로 다른 애그리거트에 속하고 있다. (실제 코드가 있으면 좋을 것 같다.)       
    
[]()  
   
1. **`Product 엔티티`와 `Review 엔티티`는 함께 생성되지 않고 함께 변경되지도 않는다.**           
2. **`Product 엔티티` 변경 주체는 상품 담당자라면 `Review 엔티티` 변경 주체는 고객이다.**     
3. **`Product 엔티티` 변경이 일어나도 `Review 엔티티`는 변경이 일어나지 않으며 반대도 마찬가지이다.**   
         
위와 같은 이유로 둘은 서로 다른 애그리거트에 속하다는 것을 알 수 있다.        
       
처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만   
도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할 수록 실제 애그리거트의 크기는 줄어들게 된다.   
다수의 엔티티가 한 개의 엔티티 객체를 갖는 경우가 많으며, 2개 이상의 엔티티로 구성되는 경우는 드물게 존재한다.   
    
# 애그리거트 루트   
주문 애그리거트는 다음을 표현한다.    
    
* 총 금액인 int totalAmounts 를 갖고 있는 Order 엔티티    
* 개별 구매 상품의 갯수인 quantity와 금액인 price 를 갖고 있는 OrderLine 벨류      
     
만약, 구매할 상품의 개수를 변경하고자 한다면        
`OrderLine`의 `quantity`를 변경하고        
`Order`의 `totalAmounts`도 변경해야한다.       
     
그렇지 않으면 `주문 총 금액은 개별 상품의 주문 개수 X 가격의 합이다`라는 도메인 규칙을 어기고 데이터 일관성이 깨진다.     
즉, **도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야한다.**   

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 **애그리거트 전체를 관리할 주체가 필요하다.**     
이렇듯 애그리거트 전체를 관리하고 책임을 지는 객체가 바로 **애그리거트 루트**이다.   
     
`애그리거트 루트 엔티티`는 애그리거트의 대표 엔티티로        
`애그리거트에 속한 객체`는 **애그리거트 루트 엔티티에 직접 또는 간접적으로 속한다.**         
   
## 도메인 규칙과 일관성   
`애그리거트 루트`가 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나지는 않는다.      
**애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는것이다.**   
이를 위해 `애그리거트 루트`는 애그리거트가 제공해야할 도메인 기능을 구현한다. (애그리거트 객체의 메서드 호출)   
  
애그리거트 루트가 제공하는 메서드는     
도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야한다.    

```java
public class Order {

    public void changeSippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
    }
    
    privae void verifyNotYetShipped() {
        if(state != OrderState.PAYMNET_WAITING && state != OrderStae.WAITING) {
            throw new IllegalStateException("aleady shipped");
        }
    }
            
}
```
`배송이 시작되기전까지만 배송지 정보 변경 가능하다.`는 도메인 규칙이 있다면    
해당 규칙에 따라 배송 시작 여부를 확인하고 변경 가능한 경우에만 배송지 정보를 변경해야한다.      

###  
애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다.     
이는 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.       

```java
@Service
@RequiredArgsConstructor
public class SampleService {
    
    private final SampleRepository sampleRepository;
    
    public void logic(Long orderId) {
        Order order = sampleRepository.findById(orderId);
        
        ShippingInfo si = order.getShippingInfo();
        si.setAddress(newAddress);
    }
    
}
```

위 코드는 애그리거트 루트인 `Order`에서 `ShippingInfo` 를 가져와 직접 정보를 변경하고 있다.  
이는 `주문상태에 따라 값을 바꿀 수 있다`는 업무 규칙을 무시하고      
DB 테이블에서 직접 데이터를 수정하는 것과 같은 결과를 만든다.       
즉, 논리적인 데이터 일관성이 깨지게 되는 것이다.     

```java
    public void logic(Long orderId) {
        Order order = sampleRepository.findById(orderId);
        
        ShippingInfo si = order.getShippingInfo();
        if(state != OrderState.PAYMENT_WAITING && state != OrderState.WAITING) {
            throw new IllegalArgumentException();
        }   
        si.setAddress(newAddress);
    }
```
  
일관성을 지키기 위해 `상태 확인 로직`을 응용 서비스에 구현할 수도 있지만,    
이렇게 되면 동일한 검사 로직을 여러 응용 서비스에서 중복해서 구현할 가능성이 높아져 상황을 악화한다.     
  
### 도메인 모델에 대한 습관   









     












   



























  
