# 애그리거트 개요  

[]()  

상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다.  
즉, **상위 수준에서 모델을 정리하면 복잡한 도메인 모델의 관계를 이해하는데 도움이된다.**      

[]() 

이렇게 작성도니 `상위 수준 모델`을 통해 `개별 객체 단위`를 나타내면 위와 같다.        
그런데 만약, `상위 수준 모델`에 대한 이해 없이 `개별 객체 단위`만 바라보게 된다면?      
더 많은 코드를 보고 도메인 전문가와 더 많은 대화를 나눠야 비로소 상위 수준에서 모델간의 관계가 이해되기 시작한다.        
쉽게 말하자면, `상 -> 하` 가 아닌 `하 -> 상`으로 도메인을 이해하는 것은 매우 어려운 일이다.    
  
앞서 언급했듯이,      
**도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고       
전반적인 구조나 큰 수준에서 도메인간의 파악이 어려워진다.**        
    
`큰 수준에서 도메인간의 파악이 어려워진다는 점`은 곧, 코드를 변경하고 확장하는 것이 어려워진다는 의미이다.      
상위 수준을 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 반영할 수 있는데 그게 아니기 때문이며        
결국에는 이렇게 망가뜨리기가 두렵기 때문에 코드 변경을 최대한 회피하는 쪽으로 협의하게 되고 꼼수를 이용해도 마찬가지이다.        

# 애그리거트 
`애그리 거트`는 **복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들어주는 단위 같은 역할을 한다.**     
앞서 설명한대로, 관련된 객체를 하나의 집합(군)으로 묶어주며     
애그리거트 단위로 바라보면 좀 더 상위 수준에서 도메인 모델간의 관계를 파악하기 쉬워진다.   
   
[]()    
  
앞선 그림과 동일한 모델이지만,     
애그리거트를 이용하게 된다면 모델간의 관계를 개별 모델 수준뿐만 아니라 상위 수준에서도 이해하기 쉽다.      

### 애그리거트와 일관성   

```java
public interface OrderRepository {
    public Order findByNumber(OrderNumber number);
    public void save(Order order);
    public void delete(Order order);
}
```   
  
애그리거트는 일관성을 관리하는 기준이 되기도 한다.      
애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.      
복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.      

### 애그리거트와 라이프 사이클  
애그리거트는 관련된 모델을 하나로 모은 것이기 때문에     
한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.      

```java
 public class Order {
    private List<OrderLine> orderLines;
    private Orderer orderer;
    private Orderer orderer;
    private ShippingInfo shippingInfo;
    
    ... // 메서드는 생략 
}
```

`주문` 애그리거트를 만들려면 `Order`, `OrderLine`, `Orderer`와 같은 관련 객체를 함께 생성해야한다.    
이와 같은 관련 객체를 만들지 않는 그런 경우는 없다.       
물론, 도메인 규칙에 따라 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만       
**대부분 애그리거트에 속한 구성요소는 함께 생성하고 함께 제거한다.**       
      
추가로, 실제 코드를 보면 객체의 참조 시점과 별개로 우선적으로 변수는 선언되어있다.          
앞서 언급했듯이 특수한 경우는 객체를 먼저 만들지 않아도 된다고 한다하더라도(생성자 주입을 안하더라도)     
`Null`값을 참조시키도록 하는 것보다, `준비 클래스`나 `default 클래스`를 만들어두는게 낫다.   
  
### 애그리거트와 경계   
애그리거트는 경계를 갖고 있어 각각의 애그리거트간의 구분이된다.         
그리고 **한 애그리트에 속한 객체는 다른 애그리거트에 속하지 않는다.**         
애그리거트는 독립된 객체 집합(군)이며, 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지않는다.          

* 주문 **--->** 배송지 변경, 주문 상품 개수 변경 
* 주문 **-X->** 회원의 비밀 번호 변경 
     
경계를 설정할 때 기본이 되는 것은 **`도메인 규칙`과 `요구사항`이다.**        
**`도메인 규칙`에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.**         
또한, 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다.   
          
예를 들면 '주문'시점에 같이 생성되는 '상품 개수', '주문자 정보' 등등이 있으며         
`OrderLine의 주문 상품 개수를 변경`하면 도메인 규칙에 따라 `Order의 총 주문 금액 또한 새롭게 계산`해야한다.       
   
### 애그리거트간의 경계 주의점
흔히, `A가 B를 갖는다.`로 설계할 수 있는 요구사항이 있다면 `A와 B`를 한 애그리거트로 묶어서 생각하기 쉽다.     
하지만, `A가 B를 갖는다`로 해석할 수 있더라도 `A와 B`가 한 애그리트에 속하다는 것은 아니다.     

```java
public class Product {
    private List<Review> reviews = new ArrayList<>(); // 단순히 연관 관계를 가진 객체로 보면 될 것 같다.   
}   
// 상품은 여러 리뷰를 가진다.   
// 리뷰는 하나의 상품에 속한다.     
// 이를 객체로 표현했을 때 위와 같아서 이렇게 표현했습니다.     
```   
  
가장 좋은 예가 `상품리뷰`이다.         
상품 상세 페이지와 함께 리뷰 내용을 보여줘야한다는 요구사항이 있다면          
`Product 엔티티`와 `Review 엔티티`가 한 애그리거트에 속한다고 생각할 수 있다.            
하지만 이 둘은 서로 다른 애그리거트에 속하고 있다. (실제 코드가 있으면 좋을 것 같다.)       
    
[]()  
   
1. **`Product 엔티티`와 `Review 엔티티`는 함께 생성되지 않고 함께 변경되지도 않는다.**           
2. **`Product 엔티티` 변경 주체는 상품 담당자라면 `Review 엔티티` 변경 주체는 고객이다.**     
3. **`Product 엔티티` 변경이 일어나도 `Review 엔티티`는 변경이 일어나지 않으며 반대도 마찬가지이다.**   
         
위와 같은 이유로 둘은 서로 다른 애그리거트에 속하다는 것을 알 수 있다.        
       
처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만   
도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할 수록 실제 애그리거트의 크기는 줄어들게 된다.   
다수의 엔티티가 한 개의 엔티티 객체를 갖는 경우가 많으며, 2개 이상의 엔티티로 구성되는 경우는 드물게 존재한다.   
    
# 애그리거트 루트   
주문 애그리거트는 다음을 표현한다.    
    
* 총 금액인 int totalAmounts 를 갖고 있는 Order 엔티티    
* 개별 구매 상품의 갯수인 quantity와 금액인 price 를 갖고 있는 OrderLine 벨류      
     
만약, 구매할 상품의 개수를 변경하고자 한다면        
`OrderLine`의 `quantity`를 변경하고        
`Order`의 `totalAmounts`도 변경해야한다.       
     
그렇지 않으면 `주문 총 금액은 개별 상품의 주문 개수 X 가격의 합이다`라는 도메인 규칙을 어기고 데이터 일관성이 깨진다.     
즉, **도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야한다.**   

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 **애그리거트 전체를 관리할 주체가 필요하다.**     
이렇듯 애그리거트 전체를 관리하고 책임을 지는 객체가 바로 **애그리거트 루트**이다.   
     
`애그리거트 루트 엔티티`는 애그리거트의 대표 엔티티로        
`애그리거트에 속한 객체`는 **애그리거트 루트 엔티티에 직접 또는 간접적으로 속한다.**         
   
## 도메인 규칙과 일관성   
`애그리거트 루트`가 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나지는 않는다.      
**애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는것이다.**   
이를 위해 `애그리거트 루트`는 애그리거트가 제공해야할 도메인 기능을 구현한다. (애그리거트 객체의 메서드 호출)   
  
애그리거트 루트가 제공하는 메서드는     
도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야한다.    

```java
public class Order {

    public void changeSippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
    }
    
    privae void verifyNotYetShipped() {
        if(state != OrderState.PAYMNET_WAITING && state != OrderStae.WAITING) {
            throw new IllegalStateException("aleady shipped");
        }
    }
            
}
```
`배송이 시작되기전까지만 배송지 정보 변경 가능하다.`는 도메인 규칙이 있다면    
해당 규칙에 따라 배송 시작 여부를 확인하고 변경 가능한 경우에만 배송지 정보를 변경해야한다.      
      
### 일관성을 지키기 위한 주의점
#### 일관성을 깬 예시     
애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다.     
이는 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.       

```java
@Service
@RequiredArgsConstructor
public class SampleService {
    
    private final SampleRepository sampleRepository;
    
    public void logic(Long orderId) {
        Order order = sampleRepository.findById(orderId);
        
        ShippingInfo si = order.getShippingInfo();
        si.setAddress(newAddress);
    }
    
}
```

위 코드는 애그리거트 루트인 `Order`에서 `ShippingInfo` 를 가져와 직접 정보를 변경하고 있다.  
이는 `주문상태에 따라 값을 바꿀 수 있다`는 업무 규칙을 무시하고      
DB 테이블에서 직접 데이터를 수정하는 것과 같은 결과를 만든다.       
즉, 논리적인 데이터 일관성이 깨지게 되는 것이다.     

```java
    public void logic(Long orderId) {
        Order order = sampleRepository.findById(orderId);
        
        ShippingInfo si = order.getShippingInfo();
        if(state != OrderState.PAYMENT_WAITING && state != OrderState.WAITING) {
            throw new IllegalArgumentException();
        }   
        si.setAddress(newAddress);
    }
```
  
일관성을 지키기 위해 `상태 확인 로직`을 응용 서비스에 구현할 수도 있지만,    
이렇게 되면 동일한 검사 로직을 여러 응용 서비스에서 중복해서 구현할 가능성이 높아져 상황을 악화한다.     
  
#### 일관서을 

불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면      
도메인 모델에 대해 다음 두 가지를 습관적으로 적용해야 한다.      

* 단순히 필드를 변경하는 `set 메서드`를 공개범위로 만들지 않는다.     
* 벨류 타입은 불변으로 구현한다.     

### set 메서드를 공개범위로 만들지 않는다.   
`public set 메서드`는 피해야한다.              
필드에 값을 할당하는 것만으로 끝나는 경우가 많으며, 많아야 `null`인지를 검사하기 때문이다.   

```java
public void setName(String name) {
    this.name = name;
}
```
`public set 메서드`는 **중요 도메인의 의미나 의도를 표현하지 못하고**        
**도메인 로직이 도메인 객체가 아닌 도메인 외부 영역을 분산되게 만드는 원인을 제공한다.**          
이는 곧, 도메인 로직이 한 곳에 응집되지 않게 만드므로 유지보수 및 코드 분석에 많은 시간을 들이게 만든다.   
  
사실, `public set 메서드`를 사용하지 않기만 해도 일관성이 깨질 가능성은 매우 줄어든다.   
또한, `private set 메서드` 또한 `changePassword()`와 같이 의미를 갖는 메서드를 사용하는 것이 좋다.   

## 벨류 타입은 불변으로 구현한다.      
벨류 객체의 값을 변경할 수 없으면     
애그리거트 루트에서 벨류 객체를 구해도 값을 변경할 수 없기에       
애그리거트 외부에서 벨류 객체의 상태를 변경할 수 없게 된다.       

```java
@Service
@RequiredArgsConstructor
public class SampleService {
    
    private final SampleRepository sampleRepository;
    
    public void logic(Long orderId) {
        Order order = sampleRepository.findById(orderId);
        
        ShippingInfo si = order.getShippingInfo();
        si.setAddress(newAddress); // ShippingInfo 벨류 객체가 불변이면 이 코드는 컴파일 에러!  
    }
}
```   

애그리거트 외부에서 내부 상태를 함부로 바꾸지 못하므로 애그리거트의 일관성이 깨질 가능성이 줄어든다.         
**벨류 객체가 불변이면 벨류 객체의 값을 변경하는 방법은 새로운 벨류 객체를 할당하는 것 뿐이다.**      

```java
public class Order {
    private ShippingInfo shippingInfo;
    
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();    
        setShippingInfo(newShippingInfo);    
    } 
    
    private void setShippingInfo(ShippingInfo newShippingInfo) {
        this.ShippingInfo = newShippingInfo;
    }
}
```
벨류 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하다.     
그러므로, 애그리거트 루트가 도메인 규칙을 올바르게만 구현하면         
애그리거트 전체의 일관성을 올바르게 유지할 수 있다.        
  
**kwj1270 생각 :**    
위 코드도 결국 외부에서 주입받는 형태인다 이게 과연 좋다고 말할 수 있을까요..?     
저는 개인적으로 `changeShippingInfo`또한 내부로 숨기고      
Order의 다른 로직에서 값을 변동시켜주는 것이 좋을 것 같아요    
그리고 `ShippingInfo` 자체적으로 `ShippingInfo`를 반환하는 로직이 있으면 좋을 것 같아요   

```java
public class ShippingInfo {
    
    private String state;
    
    public ShippingInfo(String state) {
        this.state = state;
    }
    
    public ShippingInfo change(newState) {
        return new ShippingInfo(newState);
    }
}
```

## 애그리거트 루트의 기능 구현  
`애그리거트 루트`는 **애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.**      

**총 주문 금액 계산**
```java
public class Order {
    private Money totalAmounts;
    private List<OrderLine> orderLines;
    
    private void calculateTotalAmounts() {
        int sum = orderLines.stream()
            .mapToInt(o1 -> o1.getPrice() * o1.quantity())
            .sum();
        this.totalAmounts = new Money(sum); // 재사용해도 불변이여서 좋다.    
    }
}
```

**암호 변경을 위한 패스워드 일치 확인**   
```java
public class Member {
    private Password password;
    
    public void changePassword(String currentPassword, String newPassword) { // 현재 패스워드도 외부에서 받는데 왜죠?   
        if(!password.match(currentPassword)) {
            throw new PasswordNotMatchException();
        }
        this.password = new Password(newPassword); 
    }
}
```
     
애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다.       
**기능 실행을 위임**하기도 하며 필자(kwj1270)은 이 방법을 적극 추천한다.       
     
**Order**
```java
public class Order {
    private OrderLines orderLines;
    
    public void changeOrderLines(List<OrderLine> newLines) {
        orderLines.changeOrderLines(newLines);
        this.totalAmounts = orderLines.getTotalAmounts();
    }
}
```
**OrderLines**
```java
public class OrderLines {
    private List<OrderLines> lines;
    
    pubilc OrderLines(List<OrderLine> lines) {
        this.lines = lines;
    }
    
    public OrderLines changeOrderLines(List<OrderLine> newLines) {
        this.lines = newLines;
    }
    
    public Money totalAmounts() {
        .. // 로직 구현  
    }   
}
```

`애그리거트 루트`에서 실행할 로직을 `OrderLines`내부에 위임을 했다.     
보다 정확히 말하면, 원래 `OrderLines`이 가져야할 `역할`과 `책임`을 명확히 부여했으며   
이로인해 `OrderLines`은 보다 응집도가 높아진 코드가 되었다.   
  
여기서 한 가지 더 가정을 넣으려고 한다.    
**만약, `Order` 가 `getOrderLines()`와 같은 메서드를 제공한다면?**          
아래 코드와 같이 애그리거트 외부에서 OrderLines 기능을 실행할 수 있게 되고 이는 문제다.    


```java
@Service
@RequiredArgsConstructor
public class SampleService {
    
    private final SampleRepository sampleRepository;
    
    public void logic(Long orderId) {
        Order order = sampleRepository.findById(orderId);
        
        OrderLines lines = order.getOrderLines();
        liens.changeOrderLines(newOrderLines);
    }
}
```   
  
결과적으로 버그를 만들기에 `OrderLines` 을 불변으로 구현해야한다.   
`OrderLines`을 불변하게 만들면 구조는 아래와 같다.   
   
**Order**
```java
public class Order {
    private OrderLines orderLines;
    
    public void changeOrderLines(List<OrderLine> newLines) {
        this.orderLines = orderLines.changeOrderLines(newLines);
        this.totalAmounts = orderLines.getTotalAmounts();
    }
}
```
**OrderLines** 
```java
public class OrderLines {
    private List<OrderLines> lines;
    
    pubilc OrderLines(List<OrderLine> lines) {
        this.lines = lines;
    }
    
    public OrderLines changeOrderLines(List<OrderLine> newLines) {
        return new OrderLines(newLines);
    }
    
    public Money totalAmounts() {
        .. // 로직 구현  
    }   
}
```

또한, Order 또한 다른 애그리거트 객체를 `getter로 무부별하게 반환`하지 않도록 해야한다.     
상속 같은 이유로, `private`가 불가능하다면 `protected` 변경 또한 하나의 대안이다.   

## 트랜잭션 범위  
**트랜잭션 범위는 작을수록 좋다.**     
DB 테이블을 기준으로      
한 트랜잭션이 `1개의 테이블을 수정`하는 것과 `3개의 테이블을 수정하는 것`은 성능에서 차이가 발생한다.         
  
* **1 개의 테이블을 수정한다면 :** 트랜잭션 충돌을 막기 위해서 한 개의 테이블의 한 행으로 한정된다.       
* **3 개의 테이블을 수정한다면 :** 3개의 테이블의 행들은 물론, 잠금 대상이 늘어난다.      

잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 의미하고      
이는 전체적인 성능(처리량)을 떨어뜨린다.      

동일하게, **한 트랜잭션에서는 한 개의 애그리거트만 수정해야한다.**      
한 트랜잭션에 2개의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아지기 대문에     
한 번에 수정하는 애그리거트 개수가 많아질 수록 전체 처리량이 떨어진게된다.  

**한 트랜잭션에서는 한 개의 애그리거트만 수정해야한다.** 는 말은 사실,   
**애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.**    
(한 애그리거트에서 다른 애그리거트의 상태를 변경하는 기능을 실행하면 안되는 것은 물론, 기능을 만들어서도 안된다.)   

**잘못된 예시**
```java  
public class Order {
    private Orderer orderer;
    
    public void shipTo(ShippingInfo newShippingInfo, boolean useNewShippingAddrAsMemberAddr) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
        if(userNewShippingAddrAsMemberAddr) {
            // 다른 애그리거트의 상태를 변경하면 안된다. 😢 
            orderer.getCustomer().changeAddress(newShippingInfo.getAddress());
        }
    }
}
```
배송지 정보를 변경하면서 동시에 회원의 주소를 변경하고 있다.       
이는 애그리거트가 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하는 꼴이된다.       
   
애그리거트는 서로 최대한 독립적이어야 하는데      
한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아지게된다.      
   
결합도가 높아지면 높아질수록 향후 수정 비용이 증가하므로      
애그리거트에서 다른 애그리거트의 상태를 변경하지 말아야한다.   
     
만약, 부득이하게 한 트랜잭션으로 2개 이상의 애그리거트를 수정해야한다면           
애그리거트에서 다른 애그리거트를 직접 수정하지 말고     
아래 코드와 같이 **응용 서비스에서 두 애그리거트를 수정하도록 구현해야한다.**   
   
**응용 서비스에서 두 애그리거트를 수정하는 코드**
```java
public class ChangeOrderService {
    
    @Transactional
    public void changeShippingInfo(OrderId id, ShippingInfo newShippingInfo, boolean useNewShippingAddrAsMemberAddr) {
        Order order = orderRepository.findById(id);
        if(order == null) {
            throw new OrderNotFoundException();
        }
        order.shipTo(newShippingInfo);
        if(useNewShippingAddrAsMemberAddr) {
            order.getOrderer()
                 .getCustomer()
                 .changeAddress(newShippingInfo.getAddress());
        }
    }
}
```
도메인 이벤트를 사용하면, 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도        
동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있는데 이는 나중에 살펴보자      
   
한 트랜잭션에서 한 개의 애그리거트를 변경하는 것을 권장하지만      
다음의 경우에는 한 트랜잭션에서 2개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.     
    
* **팀 표준 :**      
  팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야하는 경우가 있다.       
  DB가 다른 경우 글로벌 트랜잭션을 반드시 사용하도록 규칙을 정하는 곳도 있다.       
* **기술 제약 :**       
  한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신      
  도메인 이벤트와 비동기를 사용하는 방식을 사용하는데,      
  기술적으로 이벤트 방식을 입힐 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성이 유지되도록 처리해야한다.      
* **UI 구현의 편리 :**     
  운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다.   
  이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경할 수 있을 것이다.   
  
 
