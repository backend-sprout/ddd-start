# 애그리거트 개요  

[]()  

상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다.  
즉, **상위 수준에서 모델을 정리하면 복잡한 도메인 모델의 관계를 이해하는데 도움이된다.**      

[]() 

이렇게 작성도니 `상위 수준 모델`을 통해 `개별 객체 단위`를 나타내면 위와 같다.        
그런데 만약, `상위 수준 모델`에 대한 이해 없이 `개별 객체 단위`만 바라보게 된다면?      
더 많은 코드를 보고 도메인 전문가와 더 많은 대화를 나눠야 비로소 상위 수준에서 모델간의 관계가 이해되기 시작한다.        
쉽게 말하자면, `상 -> 하` 가 아닌 `하 -> 상`으로 도메인을 이해하는 것은 매우 어려운 일이다.    
  
앞서 언급했듯이,      
**도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고       
전반적인 구조나 큰 수준에서 도메인간의 파악이 어려워진다.**        
    
`큰 수준에서 도메인간의 파악이 어려워진다는 점`은 곧, 코드를 변경하고 확장하는 것이 어려워진다는 의미이다.      
상위 수준을 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 반영할 수 있는데 그게 아니기 때문이며        
결국에는 이렇게 망가뜨리기가 두렵기 때문에 코드 변경을 최대한 회피하는 쪽으로 협의하게 되고 꼼수를 이용해도 마찬가지이다.        

# 애그리거트 
`애그리 거트`는 **복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들어주는 단위 같은 역할을 한다.**     
앞서 설명한대로, 관련된 객체를 하나의 집합(군)으로 묶어주며     
애그리거트 단위로 바라보면 좀 더 상위 수준에서 도메인 모델간의 관계를 파악하기 쉬워진다.   
   
[]()    
  
앞선 그림과 동일한 모델이지만,     
애그리거트를 이용하게 된다면 모델간의 관계를 개별 모델 수준뿐만 아니라 상위 수준에서도 이해하기 쉽다.      

## 애그리거트와 일관성   

```java
public interface OrderRepository {
    public Order findByNumber(OrderNumber number);
    public void save(Order order);
    public void delete(Order order);
}
```   
  
애그리거트는 일관성을 관리하는 기준이 되기도 한다.      
애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.      
복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.      

## 애그리거트와 라이프 사이클  
애그리거트는 관련된 모델을 하나로 모은 것이기 때문에     
한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.      

```java
 public class Order {
    private List<OrderLine> orderLines;
    private Orderer orderer;
    private Orderer orderer;
    private ShippingInfo shippingInfo;
    
    ... // 메서드는 생략 
}
```

`주문` 애그리거트를 만들려면 `Order`, `OrderLine`, `Orderer`와 같은 관련 객체를 함께 생성해야한다.    
이와 같은 관련 객체를 만들지 않는 그런 경우는 없다.       
물론, 도메인 규칙에 따라 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만       
**대부분 애그리거트에 속한 구성요소는 함께 생성하고 함께 제거한다.**       
      
추가로, 실제 코드를 보면 객체의 참조 시점과 별개로 우선적으로 변수는 선언되어있다.          
앞서 언급했듯이 특수한 경우는 객체를 먼저 만들지 않아도 된다고 한다하더라도(생성자 주입을 안하더라도)     
`Null`값을 참조시키도록 하는 것보다, `준비 클래스`나 `default 클래스`를 만들어두는게 낫다.   
  
## 애그리거트와 경계   
애그리거트는 경계를 갖고 있어 각각의 애그리거트간의 구분이된다.         
그리고 **한 애그리트에 속한 객체는 다른 애그리거트에 속하지 않는다.**         
애그리거트는 독립된 객체 집합(군)이며, 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지않는다.          

* 주문 **--->** 배송지 변경, 주문 상품 개수 변경 
* 주문 **-X->** 회원의 비밀 번호 변경 
     
경계를 설정할 때 기본이 되는 것은 **`도메인 규칙`과 `요구사항`이다.**        
**`도메인 규칙`에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.**         
또한, 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다.   
          
예를 들면 '주문'시점에 같이 생성되는 '상품 개수', '주문자 정보' 등등이 있으며         
`OrderLine의 주문 상품 개수를 변경`하면 도메인 규칙에 따라 `Order의 총 주문 금액 또한 새롭게 계산`해야한다.       






   



























  
