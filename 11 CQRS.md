# 단일 모델의 단점  
주문 내역 조회 기능을 구현하려면 **여러 애그리거트에서 데이터를 가져와야 한다.**           
Order에서 주문 정보를 가져와야 하고,           
Product에서 상품 이름을 가져와야 하고,           
Member에서 회원 이름과 아이디를 가져와야 한다.      
   
[#](#)   
  
조회 화면의 특성상 조회 속도가 빠를 수록 좋은데           
**여러 애그리거트에서 데이터를 가져와야 할 경우 구현 방법을 고민해야 한다.**        
            
**ID를 이용해서 애그리거트를 참조하는 방식을 사용하면**         
즉시 로딩 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다.         
이는 **한 번의 select 쿼리로 조회 화면에 필요한 데이터를 읽어올 수 없어 조회 속도에 문제가 생길 수 있다.**        
   
애그리거트 간의 연관을 ID가 아니라 직접 참조하는 방식으로 연결해도 고민거리가 생긴다.              
조회 화면의 특성에 따라 같은 연관도 **즉시 로딩이나 지연 로딩으로 처리해야 하기 때문이다.**              
경우에 따라 DBMS가 제공하는 전용 기능을 이용해서            
조회 쿼리를 작성해야 해서 JPA의 네이티브 쿼리를 사용해야 할 수도 있다.               
                            
이런 고민이 발생하는 이유는 시스템의 **상태를 변경할 때**와 **조회할 때** 단일 도메인 모델을 사용하기 때문이다.              
객체 지향으로 도메인 모델을 구현할 때 주로 사용하는 ORM 기법은 `Order.cancel()` 이나               
`Order.changeShippingInfo()`처럼 도메인의 상태 변경을 구현하는 데는 적합하지만,            
주문 상세 조회 화면처럼 여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하기에는       
고려할 것들이 많아서 구현을 복잡하게 만드는 원인이 된다.          
        
이런 **구현 복잡도를 낮추는 간단한 방법이 있는데 바로 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.**              
     
# CQRS       
시스템이 제공하는 기능은 크게 2가지로 나누어 생각해볼 수 있다.                  
하나는 상태를 변경하는 기능이다.                    
새로운 주문을 생성하거나, 배송지 정보를 변경하거나, 회원의 암호를 변경하는 기능이 이에 해당한다.                  
개발자는 현재 저장하고 있는 데이터를 변경하는 방식으로 기능을 구현한다.       
  
또 다른 하나는 사용자 입장에서 상태 정보를 조회하는 기능이다.         
주문 상세 내역 보기, 게시물 목록 보기, 회원 정보 보기, 판매 통계 보기가 이에 해당한다.       
조회 기능은 필요한 데이터를 읽어와 UI를 통해 보여주는 방식으로 구현한다.    
       
도메인 모델 관점에서 **상태 변경 기능은 주로 한 애그리거트의 상태를 변경한다.**        
예를 들어, 주문 최소 기능과 배송지 정보 변경 기능은 한개의 Order 애그리거트를 변경한다.    
반면에 조회 기능은 두 개 이상의 애그리거트에서 데이터를 조회할 수 있다.    
    
상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에    
단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.    
**단일 모델을 사용할 때 발생하는 복잡도를 해결하기 위해 사용하는 방법이 있는데. 그것이 CQRS 이다.**   
  
CQRS는 Command Query Responsibility Segregation의 약자로      
**상태를 변경하는 명령을 위한 모델**과 **상태를 제공하는 조회를 위한 모델**을 **분리**하는 패턴이다.     
          
CQRS는 복잡한 도메인에 적합하다.           
도메인이 복잡할수록 **명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 발생하는데,**        
이 두 기능을 단일 모델로 처리하게 되면 조회 기능의 로딩속도를 위해 모델 구현이 필요 이상으로 복잡해지는 문제가 발생한다.     
      
예를 들어, 온라인 쇼핑에서 다양한 차원에서 주문/판매 통계를 조회해야 한다고 가정하면     
JPA 기반의 단일 도메인 모델을 사용하면 통계 값을 빠르게 조회하기 위해 JPA와 관련된 다양한 성능 관련 기능을 모델에 적용해야한다.       
이런 도메인에 CQRS를 적용하면 통계를 위한 조회 모델을 별도로 만들기 때문에 조회 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.   
  
CQRS를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다.     
예를 들어, 명령 모델은 객체지 향에 기반해서 도메인 모델을 구현하기에 적당한 JPA를 사용해서 구현하고     
조회 모델은 DB테이블에서 SQL로 데이터를 조회할 때 좋은 MyBatis를 사용해서 구현할 수 있다.      

[#](#)   

위 그림을 보면 조회 모델에는 응용 서비스가 존재하지 않는다.         
단순히 데이터를 읽어와 조회하는 기능은 응용 로직이 복잡하지 않기 때문에 컨틀롤러에서 바로 DAO를 실행해도 무방하다.            
물론, 데이터를 표현 영역에 전달하는 과정에서 몇가지 로직이 필요하다면 응용 서비스를 두고 로직을 구현하면 된다.      

[#](#) 

위 그림은 명령 모델과 조회 모델의 설계 예를 보여주고 있다.             
**상태 변경을 위한 명령 모델은 객체를 기반으로 한 도메인 모델을 이용해서 구현한다.**                 
**반면에 조회 모델은 주문 요약 목록을 제공할 때 필요한 정보를 담고 있는 데이터 타입을 이용한다.(리터럴)**         
  
두 모델 모두 주문과 관련되어 있지만        
명령 모델은 상태를 변경하는 도메인 로직을 수행하는 데 초점을 맞춰 설계했고          
조회 모델은 화면에 보여줄 데이터를 조회하는 데 초점을 맞춰 설계했다.      

물론, 명령 모델과 조회 모델이 같은 구현 기술을 사용할 수도 있다.(JPQL 사용해서 조회)   








  
